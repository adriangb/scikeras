{
 "cells": [
  {
   "cell_type": "raw",
   "id": "51799427",
   "metadata": {},
   "source": [
    "<a href=\"https://colab.research.google.com/github/adriangb/scikeras/blob/docs-deploy/refs/heads/master/notebooks/Basic_Usage.ipynb\"><img src=\"https://www.tensorflow.org/images/colab_logo_32px.png\">Run in Google Colab</a>"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "533f7413",
   "metadata": {},
   "source": [
    "# Basic usage\n",
    "\n",
    "`SciKeras` is designed to maximize interoperability between `sklearn` and `Keras/TensorFlow`. The aim is to keep 99% of the flexibility of `Keras` while being able to leverage most features of `sklearn`. Below, we show the basic usage of `SciKeras` and how it can be combined with `sklearn`.\n",
    "\n",
    "This notebook shows you how to use the basic functionality of `SciKeras`.\n",
    "\n",
    "## Table of contents\n",
    "\n",
    "* [1. Setup](#1.-Setup)\n",
    "* [2. Training a classifier and making predictions](#2.-Training-a-classifier-and-making-predictions)\n",
    "  * [2.1 A toy binary classification task](#2.1-A-toy-binary-classification-task)\n",
    "  * [2.2 Definition of the Keras classification Model](#2.2-Definition-of-the-Keras-classification-Model)\n",
    "  * [2.3 Defining and training the neural net classifier](#2.3-Defining-and-training-the-neural-net-classifier)\n",
    "  * [2.4 Making predictions, classification](#2.4-Making-predictions-classification)\n",
    "* [3 Training a regressor](#3.-Training-a-regressor)\n",
    "  * [3.1 A toy regression task](#3.1-A-toy-regression-task)\n",
    "  * [3.2 Definition of the Keras regression Model](#3.2-Definition-of-the-Keras-regression-Model)\n",
    "  * [3.3 Defining and training the neural net regressor](#3.3-Defining-and-training-the-neural-net-regressor)\n",
    "  * [3.4 Making predictions, regression](#3.4-Making-predictions-regression)\n",
    "* [4. Saving and loading a model](#4.-Saving-and-loading-a-model)\n",
    "  * [4.1 Saving the whole model](#4.1-Saving-the-whole-model)\n",
    "  * [4.2 Saving using Keras' saving methods](#4.2-Saving-using-Keras-saving-methods)\n",
    "* [5. Usage with an sklearn Pipeline](#5.-Usage-with-an-sklearn-Pipeline)\n",
    "* [6. Callbacks](#6.-Callbacks)\n",
    "* [7. Usage with sklearn GridSearchCV](#7.-Usage-with-sklearn-GridSearchCV)\n",
    "  * [7.1 Special prefixes](#7.1-Special-prefixes)\n",
    "  * [7.2 Performing a grid search](#7.2-Performing-a-grid-search)\n",
    "\n",
    "## 1. Setup"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "3f54a015",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-07-22T23:27:11.119016Z",
     "iopub.status.busy": "2022-07-22T23:27:11.118686Z",
     "iopub.status.idle": "2022-07-22T23:27:13.856283Z",
     "shell.execute_reply": "2022-07-22T23:27:13.850389Z"
    }
   },
   "outputs": [],
   "source": [
    "try:\n",
    "    import scikeras\n",
    "except ImportError:\n",
    "    !python -m pip install scikeras"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "191c4c9d",
   "metadata": {},
   "source": [
    "Silence TensorFlow logging to keep output succinct."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "d0013aca",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-07-22T23:27:13.861656Z",
     "iopub.status.busy": "2022-07-22T23:27:13.860477Z",
     "iopub.status.idle": "2022-07-22T23:27:13.869852Z",
     "shell.execute_reply": "2022-07-22T23:27:13.868275Z"
    }
   },
   "outputs": [],
   "source": [
    "import warnings\n",
    "from tensorflow import get_logger\n",
    "get_logger().setLevel('ERROR')\n",
    "warnings.filterwarnings(\"ignore\", message=\"Setting the random state for TF\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "a66fe71c",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-07-22T23:27:13.873459Z",
     "iopub.status.busy": "2022-07-22T23:27:13.872762Z",
     "iopub.status.idle": "2022-07-22T23:27:14.150831Z",
     "shell.execute_reply": "2022-07-22T23:27:14.149995Z"
    }
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "from scikeras.wrappers import KerasClassifier, KerasRegressor\n",
    "from tensorflow import keras"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c6c2f668",
   "metadata": {},
   "source": [
    "## 2. Training a classifier and making predictions\n",
    "\n",
    "### 2.1 A toy binary classification task\n",
    "\n",
    "We load a toy classification task from `sklearn`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "d8057ab4",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-07-22T23:27:14.155032Z",
     "iopub.status.busy": "2022-07-22T23:27:14.154566Z",
     "iopub.status.idle": "2022-07-22T23:27:14.236415Z",
     "shell.execute_reply": "2022-07-22T23:27:14.235701Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "((1000, 20), (1000,), 0.5)"
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import numpy as np\n",
    "from sklearn.datasets import make_classification\n",
    "\n",
    "\n",
    "X, y = make_classification(1000, 20, n_informative=10, random_state=0)\n",
    "\n",
    "X.shape, y.shape, y.mean()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8164622c",
   "metadata": {},
   "source": [
    "### 2.2 Definition of the Keras classification Model\n",
    "\n",
    "We define a vanilla neural network with.\n",
    "\n",
    "Because we are dealing with 2 classes, the output layer can be constructed in\n",
    "two different ways:\n",
    "\n",
    "1. Single unit with a `\"sigmoid\"` nonlinearity. The loss must be `\"binary_crossentropy\"`.\n",
    "2. Two units (one for each class) and a `\"softmax\"` nonlinearity. The loss must be `\"sparse_categorical_crossentropy\"`.\n",
    "\n",
    "In this example, we choose the first option, which is what you would usually\n",
    "do for binary classification. The second option is usually reserved for when\n",
    "you have >2 classes."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "35123545",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-07-22T23:27:14.245868Z",
     "iopub.status.busy": "2022-07-22T23:27:14.244373Z",
     "iopub.status.idle": "2022-07-22T23:27:14.251786Z",
     "shell.execute_reply": "2022-07-22T23:27:14.251124Z"
    }
   },
   "outputs": [],
   "source": [
    "from tensorflow import keras\n",
    "\n",
    "\n",
    "def get_clf(meta, hidden_layer_sizes, dropout):\n",
    "    n_features_in_ = meta[\"n_features_in_\"]\n",
    "    n_classes_ = meta[\"n_classes_\"]\n",
    "    model = keras.models.Sequential()\n",
    "    model.add(keras.layers.Input(shape=(n_features_in_,)))\n",
    "    for hidden_layer_size in hidden_layer_sizes:\n",
    "        model.add(keras.layers.Dense(hidden_layer_size, activation=\"relu\"))\n",
    "        model.add(keras.layers.Dropout(dropout))\n",
    "    model.add(keras.layers.Dense(1, activation=\"sigmoid\"))\n",
    "    return model"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cf1eb646",
   "metadata": {},
   "source": [
    "### 2.3 Defining and training the neural net classifier\n",
    "\n",
    "We use `KerasClassifier` because we're dealing with a classifcation task. The first argument should be a callable returning a `Keras.Model`, in this case, `get_clf`. As additional arguments, we pass the number of loss function (required) and the optimizer, but the later is optional. We must also pass all of the arguments to `get_clf` as keyword arguments to `KerasClassifier` if they don't have a default value in `get_clf`. Note that if you do not pass an argument to `KerasClassifier`, it will not be avilable for hyperparameter tuning. Finally, we also pass `random_state=0` for reproducible results."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "981db4f7",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-07-22T23:27:14.257530Z",
     "iopub.status.busy": "2022-07-22T23:27:14.256269Z",
     "iopub.status.idle": "2022-07-22T23:27:14.263668Z",
     "shell.execute_reply": "2022-07-22T23:27:14.262959Z"
    }
   },
   "outputs": [],
   "source": [
    "from scikeras.wrappers import KerasClassifier\n",
    "\n",
    "\n",
    "clf = KerasClassifier(\n",
    "    model=get_clf,\n",
    "    loss=\"binary_crossentropy\",\n",
    "    hidden_layer_sizes=(100,),\n",
    "    dropout=0.5,\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "31dac0db",
   "metadata": {},
   "source": [
    "As in `sklearn`, we call `fit` passing the input data `X` and the targets `y`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "9e90f987",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-07-22T23:27:14.270386Z",
     "iopub.status.busy": "2022-07-22T23:27:14.269140Z",
     "iopub.status.idle": "2022-07-22T23:27:15.173460Z",
     "shell.execute_reply": "2022-07-22T23:27:15.169290Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\r",
      " 1/32 [..............................] - ETA: 18s - loss: 1.0520"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\r",
      "32/32 [==============================] - 1s 1ms/step - loss: 0.8901\n"
     ]
    }
   ],
   "source": [
    "clf.fit(X, y);"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0a48bdc7",
   "metadata": {},
   "source": [
    "Also, as in `sklearn`, you may call `predict` or `predict_proba` on the fitted model.\n",
    "\n",
    "### 2.4 Making predictions, classification"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "943c3733",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-07-22T23:27:15.177821Z",
     "iopub.status.busy": "2022-07-22T23:27:15.177485Z",
     "iopub.status.idle": "2022-07-22T23:27:15.349366Z",
     "shell.execute_reply": "2022-07-22T23:27:15.348592Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\r",
      "1/1 [==============================] - ETA: 0s"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\r",
      "1/1 [==============================] - 0s 105ms/step\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "array([0, 0, 0, 0, 0])"
      ]
     },
     "execution_count": 8,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "y_pred = clf.predict(X[:5])\n",
    "y_pred"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "b12450e9",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-07-22T23:27:15.357105Z",
     "iopub.status.busy": "2022-07-22T23:27:15.356538Z",
     "iopub.status.idle": "2022-07-22T23:27:15.431271Z",
     "shell.execute_reply": "2022-07-22T23:27:15.430431Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\r",
      "1/1 [==============================] - ETA: 0s"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\r",
      "1/1 [==============================] - 0s 29ms/step\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "array([[0.74995095, 0.25004905],\n",
       "       [0.60853124, 0.3914688 ],\n",
       "       [0.7820543 , 0.2179457 ],\n",
       "       [0.8180869 , 0.18191306],\n",
       "       [0.5154103 , 0.48458973]], dtype=float32)"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "y_proba = clf.predict_proba(X[:5])\n",
    "y_proba"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ddffa2c9",
   "metadata": {},
   "source": [
    "## 3 Training a regressor\n",
    "\n",
    "### 3.1 A toy regression task"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "176d3777",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-07-22T23:27:15.435662Z",
     "iopub.status.busy": "2022-07-22T23:27:15.435058Z",
     "iopub.status.idle": "2022-07-22T23:27:15.446567Z",
     "shell.execute_reply": "2022-07-22T23:27:15.445840Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "((1000, 20), (1000,), -649.0148244404172, 615.4505181286091)"
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "from sklearn.datasets import make_regression\n",
    "\n",
    "\n",
    "X_regr, y_regr = make_regression(1000, 20, n_informative=10, random_state=0)\n",
    "\n",
    "X_regr.shape, y_regr.shape, y_regr.min(), y_regr.max()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bb8e1ed0",
   "metadata": {},
   "source": [
    "### 3.2 Definition of the Keras regression Model\n",
    "\n",
    "Again, define a vanilla neural network. The main difference is that the output layer always has a single unit and does not apply any nonlinearity."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "b92d43cb",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-07-22T23:27:15.451962Z",
     "iopub.status.busy": "2022-07-22T23:27:15.450672Z",
     "iopub.status.idle": "2022-07-22T23:27:15.457139Z",
     "shell.execute_reply": "2022-07-22T23:27:15.456470Z"
    }
   },
   "outputs": [],
   "source": [
    "def get_reg(meta, hidden_layer_sizes, dropout):\n",
    "    n_features_in_ = meta[\"n_features_in_\"]\n",
    "    model = keras.models.Sequential()\n",
    "    model.add(keras.layers.Input(shape=(n_features_in_,)))\n",
    "    for hidden_layer_size in hidden_layer_sizes:\n",
    "        model.add(keras.layers.Dense(hidden_layer_size, activation=\"relu\"))\n",
    "        model.add(keras.layers.Dropout(dropout))\n",
    "    model.add(keras.layers.Dense(1))\n",
    "    return model"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bb9b49b2",
   "metadata": {},
   "source": [
    "### 3.3 Defining and training the neural net regressor\n",
    "\n",
    "Training a regressor has nearly the same data flow as training a classifier. The differences include using `KerasRegressor` instead of `KerasClassifier` and adding `KerasRegressor.r_squared` as a metric. Most of the Scikit-learn regressors use the coefficient of determination or R^2 as a metric function, which measures correlation between the true labels and predicted labels."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "789b8050",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-07-22T23:27:15.462320Z",
     "iopub.status.busy": "2022-07-22T23:27:15.461087Z",
     "iopub.status.idle": "2022-07-22T23:27:15.467652Z",
     "shell.execute_reply": "2022-07-22T23:27:15.466952Z"
    }
   },
   "outputs": [],
   "source": [
    "from scikeras.wrappers import KerasRegressor\n",
    "\n",
    "\n",
    "reg = KerasRegressor(\n",
    "    model=get_reg,\n",
    "    loss=\"mse\",\n",
    "    metrics=[KerasRegressor.r_squared],\n",
    "    hidden_layer_sizes=(100,),\n",
    "    dropout=0.5,\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "65084ec1",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-07-22T23:27:15.472596Z",
     "iopub.status.busy": "2022-07-22T23:27:15.471388Z",
     "iopub.status.idle": "2022-07-22T23:27:16.202568Z",
     "shell.execute_reply": "2022-07-22T23:27:16.201779Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\r",
      " 1/32 [..............................] - ETA: 17s - loss: 25590.9922 - r_squared: -0.0468"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\r",
      "28/32 [=========================>....] - ETA: 0s - loss: 44080.6484 - r_squared: -0.0396 "
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\r",
      "32/32 [==============================] - 1s 2ms/step - loss: 45070.0273 - r_squared: -0.0355\n"
     ]
    }
   ],
   "source": [
    "reg.fit(X_regr, y_regr);"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1b4a0abd",
   "metadata": {},
   "source": [
    "### 3.4 Making predictions, regression\n",
    "\n",
    "You may call `predict` or `predict_proba` on the fitted model. For regressions, both methods return the same value."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "569ef419",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-07-22T23:27:16.208443Z",
     "iopub.status.busy": "2022-07-22T23:27:16.207097Z",
     "iopub.status.idle": "2022-07-22T23:27:16.362122Z",
     "shell.execute_reply": "2022-07-22T23:27:16.361349Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\r",
      "1/1 [==============================] - ETA: 0s"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\r",
      "1/1 [==============================] - 0s 94ms/step\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "array([ 1.347404  , -0.8740094 ,  0.89308965,  0.23444152,  0.21015461],\n",
       "      dtype=float32)"
      ]
     },
     "execution_count": 14,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "y_pred = reg.predict(X_regr[:5])\n",
    "y_pred"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "76dff91a",
   "metadata": {},
   "source": [
    "## 4. Saving and loading a model\n",
    "\n",
    "Save and load either the whole model by using pickle, or use Keras' specialized save methods on the `KerasClassifier.model_` or `KerasRegressor.model_` attribute that is created after fitting. You will want to use Keras' model saving utilities if any of the following apply:\n",
    "\n",
    "1. You wish to save only the weights or only the training configuration of your model.\n",
    "2. You wish to share your model with collaborators. Pickle is a relatively unsafe protocol and it is not recommended to share or load pickle objects publically.\n",
    "3. You care about performance, especially if doing in-memory serialization.\n",
    "\n",
    "For more information, see Keras' [saving documentation](https://www.tensorflow.org/guide/keras/save_and_serialize).\n",
    "\n",
    "### 4.1 Saving the whole model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "f218d2af",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-07-22T23:27:16.366431Z",
     "iopub.status.busy": "2022-07-22T23:27:16.365907Z",
     "iopub.status.idle": "2022-07-22T23:27:17.907634Z",
     "shell.execute_reply": "2022-07-22T23:27:17.906866Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\r",
      "1/1 [==============================] - ETA: 0s"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\r",
      "1/1 [==============================] - 0s 62ms/step\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "array([ 1.347404  , -0.8740094 ,  0.89308965,  0.23444152,  0.21015461],\n",
       "      dtype=float32)"
      ]
     },
     "execution_count": 15,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import pickle\n",
    "\n",
    "\n",
    "bytes_model = pickle.dumps(reg)\n",
    "new_reg = pickle.loads(bytes_model)\n",
    "new_reg.predict(X_regr[:5])  # model is still trained"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bbf7805d",
   "metadata": {},
   "source": [
    "### 4.2 Saving using Keras' saving methods\n",
    "\n",
    "This efficiently and safely saves the model to disk, including trained weights.\n",
    "You should use this method if you plan on sharing your saved models."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "887262ff",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-07-22T23:27:17.911764Z",
     "iopub.status.busy": "2022-07-22T23:27:17.911207Z",
     "iopub.status.idle": "2022-07-22T23:27:18.628940Z",
     "shell.execute_reply": "2022-07-22T23:27:18.628080Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\r",
      " 1/32 [..............................] - ETA: 0s"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\r",
      "32/32 [==============================] - 0s 1ms/step\n"
     ]
    }
   ],
   "source": [
    "# Save to disk\n",
    "pred_old = reg.predict(X_regr)\n",
    "reg.model_.save(\"/tmp/my_model\")  # saves just the Keras model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "0c161950",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-07-22T23:27:18.640917Z",
     "iopub.status.busy": "2022-07-22T23:27:18.634484Z",
     "iopub.status.idle": "2022-07-22T23:27:19.163556Z",
     "shell.execute_reply": "2022-07-22T23:27:19.161627Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\r",
      " 1/32 [..............................] - ETA: 1s"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\r",
      "32/32 [==============================] - 0s 1ms/step\n"
     ]
    }
   ],
   "source": [
    "# Load the model back into memory\n",
    "new_reg_model = keras.models.load_model(\"/tmp/my_model\")\n",
    "# Now we need to instantiate a new SciKeras object\n",
    "# since we only saved the Keras model\n",
    "reg_new = KerasRegressor(new_reg_model)\n",
    "# use initialize to avoid re-fitting\n",
    "reg_new.initialize(X_regr, y_regr)\n",
    "pred_new = reg_new.predict(X_regr)\n",
    "np.testing.assert_allclose(pred_old, pred_new)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1215d039",
   "metadata": {},
   "source": [
    "## 5. Usage with an sklearn Pipeline\n",
    "\n",
    "It is possible to put the `KerasClassifier` inside an `sklearn Pipeline`, as you would with any `sklearn` classifier.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "29508581",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-07-22T23:27:19.169507Z",
     "iopub.status.busy": "2022-07-22T23:27:19.168181Z",
     "iopub.status.idle": "2022-07-22T23:27:20.051902Z",
     "shell.execute_reply": "2022-07-22T23:27:20.050967Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\r",
      " 1/32 [..............................] - ETA: 15s - loss: 0.7543"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\r",
      "32/32 [==============================] - 1s 2ms/step - loss: 0.7126\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\r",
      " 1/32 [..............................] - ETA: 1s"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\r",
      "32/32 [==============================] - 0s 2ms/step\n"
     ]
    }
   ],
   "source": [
    "from sklearn.pipeline import Pipeline\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "\n",
    "\n",
    "pipe = Pipeline([\n",
    "    ('scale', StandardScaler()),\n",
    "    ('clf', clf),\n",
    "])\n",
    "\n",
    "\n",
    "y_proba = pipe.fit(X, y).predict(X)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "230615ac",
   "metadata": {},
   "source": [
    "To save the whole pipeline, including the Keras model, use `pickle`.\n",
    "\n",
    "## 6. Callbacks\n",
    "\n",
    "Adding a new callback to the model is straightforward. Below we define a threashold callback\n",
    "to avoid training past a certain accuracy. This a rudimentary for of\n",
    "[early stopping](https://www.tensorflow.org/api_docs/python/tf/keras/callbacks/EarlyStopping)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "661c0e05",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-07-22T23:27:20.063116Z",
     "iopub.status.busy": "2022-07-22T23:27:20.058416Z",
     "iopub.status.idle": "2022-07-22T23:27:20.071714Z",
     "shell.execute_reply": "2022-07-22T23:27:20.069794Z"
    }
   },
   "outputs": [],
   "source": [
    "class MaxValLoss(keras.callbacks.Callback):\n",
    "\n",
    "    def __init__(self, monitor: str, threashold: float):\n",
    "        self.monitor = monitor\n",
    "        self.threashold = threashold\n",
    "\n",
    "    def on_epoch_end(self, epoch, logs=None):\n",
    "        if logs[self.monitor] > self.threashold:\n",
    "            print(\"Threashold reached; stopping training\") \n",
    "            self.model.stop_training = True"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7b4aea43",
   "metadata": {},
   "source": [
    "Define a test dataset:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "5fd5ff21",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-07-22T23:27:20.076530Z",
     "iopub.status.busy": "2022-07-22T23:27:20.076236Z",
     "iopub.status.idle": "2022-07-22T23:27:20.097729Z",
     "shell.execute_reply": "2022-07-22T23:27:20.095080Z"
    }
   },
   "outputs": [],
   "source": [
    "from sklearn.datasets import make_moons\n",
    "\n",
    "\n",
    "X, y = make_moons(n_samples=100, noise=0.2, random_state=0)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "00e4455d",
   "metadata": {},
   "source": [
    "And try fitting it with and without the callback:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "b92ebb8c",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-07-22T23:27:20.102854Z",
     "iopub.status.busy": "2022-07-22T23:27:20.102531Z",
     "iopub.status.idle": "2022-07-22T23:27:22.234081Z",
     "shell.execute_reply": "2022-07-22T23:27:22.233068Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Trained 20 epochs\n",
      "Final accuracy: 1.0\n"
     ]
    }
   ],
   "source": [
    "kwargs = dict(\n",
    "    model=get_clf,\n",
    "    loss=\"binary_crossentropy\",\n",
    "    dropout=0.5,\n",
    "    hidden_layer_sizes=(100,),\n",
    "    metrics=[\"binary_accuracy\"],\n",
    "    fit__validation_split=0.2,\n",
    "    epochs=20,\n",
    "    verbose=False,\n",
    "    random_state=0\n",
    ")\n",
    "\n",
    "# First test without the callback\n",
    "clf = KerasClassifier(**kwargs)\n",
    "clf.fit(X, y)\n",
    "print(f\"Trained {len(clf.history_['loss'])} epochs\")\n",
    "print(f\"Final accuracy: {clf.history_['val_binary_accuracy'][-1]}\")  # get last value of last fit/partial_fit call"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c4844fac",
   "metadata": {},
   "source": [
    "And with:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "0fd2e38c",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-07-22T23:27:22.239916Z",
     "iopub.status.busy": "2022-07-22T23:27:22.238336Z",
     "iopub.status.idle": "2022-07-22T23:27:23.158006Z",
     "shell.execute_reply": "2022-07-22T23:27:23.157119Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Threashold reached; stopping training\n",
      "Trained 2 epochs\n",
      "Final accuracy: 0.949999988079071\n"
     ]
    }
   ],
   "source": [
    "# Test with the callback\n",
    "\n",
    "cb = MaxValLoss(monitor=\"val_binary_accuracy\", threashold=0.75)\n",
    "\n",
    "clf = KerasClassifier(\n",
    "    **kwargs,\n",
    "    callbacks=[cb]\n",
    ")\n",
    "clf.fit(X, y)\n",
    "print(f\"Trained {len(clf.history_['loss'])} epochs\")\n",
    "print(f\"Final accuracy: {clf.history_['val_binary_accuracy'][-1]}\")  # get last value of last fit/partial_fit call"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "99fbf254",
   "metadata": {},
   "source": [
    "For information on how to write custom callbacks, have a look at the\n",
    "[Advanced Usage](https://nbviewer.jupyter.org/github/adriangb/scikeras/blob/master/notebooks/Advanced_Usage.ipynb) notebook.\n",
    "\n",
    "## 7. Usage with sklearn GridSearchCV\n",
    "\n",
    "### 7.1 Special prefixes\n",
    "\n",
    "SciKeras allows to direct access to all parameters passed to the wrapper constructors, including deeply nested routed parameters. This allows tunning of\n",
    "paramters like `hidden_layer_sizes` as well as `optimizer__learning_rate`.\n",
    "\n",
    "This is exactly the same logic that allows to access estimator parameters in `sklearn Pipeline`s and `FeatureUnion`s.\n",
    "\n",
    "This feature is useful in several ways. For one, it allows to set those parameters in the model definition. Furthermore, it allows you to set parameters in an `sklearn GridSearchCV` as shown below.\n",
    "\n",
    "To differentiate paramters like `callbacks` which are accepted by both `tf.keras.Model.fit` and `tf.keras.Model.predict` you can add a `fit__` or `predict__` routing suffix respectively. Similar, the `model__` prefix may be used to specify that a paramter is destined only for `get_clf`/`get_reg` (or whatever callable you pass as your `model` argument).\n",
    "\n",
    "For more information on parameter routing with special prefixes, see the [Advanced Usage Docs](https://www.adriangb.com/scikeras/stable/advanced.html#routed-parameters)\n",
    "\n",
    "### 7.2 Performing a grid search\n",
    "\n",
    "Below we show how to perform a grid search over the learning rate (`optimizer__lr`), the model's number of hidden layers (`model__hidden_layer_sizes`), the model's dropout rate (`model__dropout`)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "id": "90e190cb",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-07-22T23:27:23.164542Z",
     "iopub.status.busy": "2022-07-22T23:27:23.163018Z",
     "iopub.status.idle": "2022-07-22T23:27:23.239793Z",
     "shell.execute_reply": "2022-07-22T23:27:23.238875Z"
    }
   },
   "outputs": [],
   "source": [
    "from sklearn.model_selection import GridSearchCV\n",
    "\n",
    "\n",
    "clf = KerasClassifier(\n",
    "    model=get_clf,\n",
    "    loss=\"binary_crossentropy\",\n",
    "    optimizer=\"adam\",\n",
    "    optimizer__lr=0.1,\n",
    "    model__hidden_layer_sizes=(100,),\n",
    "    model__dropout=0.5,\n",
    "    verbose=False,\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ad2d0961",
   "metadata": {},
   "source": [
    "*Note*: We set the verbosity level to zero (`verbose=False`) to prevent too much print output from being shown."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "id": "93429dea",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-07-22T23:27:23.245859Z",
     "iopub.status.busy": "2022-07-22T23:27:23.244433Z",
     "iopub.status.idle": "2022-07-22T23:27:52.779675Z",
     "shell.execute_reply": "2022-07-22T23:27:52.778351Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Fitting 5 folds for each of 8 candidates, totalling 40 fits\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/home/runner/work/scikeras/scikeras/.venv/lib/python3.8/site-packages/keras/optimizers/optimizer_v2/adam.py:110: UserWarning: The `lr` argument is deprecated, use `learning_rate` instead.\n",
      "  super(Adam, self).__init__(name, **kwargs)\n",
      "/home/runner/work/scikeras/scikeras/.venv/lib/python3.8/site-packages/keras/optimizers/optimizer_v2/adam.py:110: UserWarning: The `lr` argument is deprecated, use `learning_rate` instead.\n",
      "  super(Adam, self).__init__(name, **kwargs)\n",
      "/home/runner/work/scikeras/scikeras/.venv/lib/python3.8/site-packages/keras/optimizers/optimizer_v2/adam.py:110: UserWarning: The `lr` argument is deprecated, use `learning_rate` instead.\n",
      "  super(Adam, self).__init__(name, **kwargs)\n",
      "/home/runner/work/scikeras/scikeras/.venv/lib/python3.8/site-packages/keras/optimizers/optimizer_v2/adam.py:110: UserWarning: The `lr` argument is deprecated, use `learning_rate` instead.\n",
      "  super(Adam, self).__init__(name, **kwargs)\n",
      "/home/runner/work/scikeras/scikeras/.venv/lib/python3.8/site-packages/keras/optimizers/optimizer_v2/adam.py:110: UserWarning: The `lr` argument is deprecated, use `learning_rate` instead.\n",
      "  super(Adam, self).__init__(name, **kwargs)\n",
      "WARNING:tensorflow:5 out of the last 13 calls to <function Model.make_train_function.<locals>.train_function at 0x7f02503d0ee0> triggered tf.function retracing. Tracing is expensive and the excessive number of tracings could be due to (1) creating @tf.function repeatedly in a loop, (2) passing tensors with different shapes, (3) passing Python objects instead of tensors. For (1), please define your @tf.function outside of the loop. For (2), @tf.function has reduce_retracing=True option that can avoid unnecessary retracing. For (3), please refer to https://www.tensorflow.org/guide/function#controlling_retracing and https://www.tensorflow.org/api_docs/python/tf/function for  more details.\n",
      "WARNING:tensorflow:5 out of the last 5 calls to <function Model.make_predict_function.<locals>.predict_function at 0x7f0250373820> triggered tf.function retracing. Tracing is expensive and the excessive number of tracings could be due to (1) creating @tf.function repeatedly in a loop, (2) passing tensors with different shapes, (3) passing Python objects instead of tensors. For (1), please define your @tf.function outside of the loop. For (2), @tf.function has reduce_retracing=True option that can avoid unnecessary retracing. For (3), please refer to https://www.tensorflow.org/guide/function#controlling_retracing and https://www.tensorflow.org/api_docs/python/tf/function for  more details.\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/home/runner/work/scikeras/scikeras/.venv/lib/python3.8/site-packages/keras/optimizers/optimizer_v2/adam.py:110: UserWarning: The `lr` argument is deprecated, use `learning_rate` instead.\n",
      "  super(Adam, self).__init__(name, **kwargs)\n",
      "/home/runner/work/scikeras/scikeras/.venv/lib/python3.8/site-packages/keras/optimizers/optimizer_v2/adam.py:110: UserWarning: The `lr` argument is deprecated, use `learning_rate` instead.\n",
      "  super(Adam, self).__init__(name, **kwargs)\n",
      "/home/runner/work/scikeras/scikeras/.venv/lib/python3.8/site-packages/keras/optimizers/optimizer_v2/adam.py:110: UserWarning: The `lr` argument is deprecated, use `learning_rate` instead.\n",
      "  super(Adam, self).__init__(name, **kwargs)\n",
      "/home/runner/work/scikeras/scikeras/.venv/lib/python3.8/site-packages/keras/optimizers/optimizer_v2/adam.py:110: UserWarning: The `lr` argument is deprecated, use `learning_rate` instead.\n",
      "  super(Adam, self).__init__(name, **kwargs)\n",
      "/home/runner/work/scikeras/scikeras/.venv/lib/python3.8/site-packages/keras/optimizers/optimizer_v2/adam.py:110: UserWarning: The `lr` argument is deprecated, use `learning_rate` instead.\n",
      "  super(Adam, self).__init__(name, **kwargs)\n",
      "WARNING:tensorflow:5 out of the last 13 calls to <function Model.make_train_function.<locals>.train_function at 0x7faf311d1e50> triggered tf.function retracing. Tracing is expensive and the excessive number of tracings could be due to (1) creating @tf.function repeatedly in a loop, (2) passing tensors with different shapes, (3) passing Python objects instead of tensors. For (1), please define your @tf.function outside of the loop. For (2), @tf.function has reduce_retracing=True option that can avoid unnecessary retracing. For (3), please refer to https://www.tensorflow.org/guide/function#controlling_retracing and https://www.tensorflow.org/api_docs/python/tf/function for  more details.\n",
      "WARNING:tensorflow:5 out of the last 5 calls to <function Model.make_predict_function.<locals>.predict_function at 0x7faf310aa8b0> triggered tf.function retracing. Tracing is expensive and the excessive number of tracings could be due to (1) creating @tf.function repeatedly in a loop, (2) passing tensors with different shapes, (3) passing Python objects instead of tensors. For (1), please define your @tf.function outside of the loop. For (2), @tf.function has reduce_retracing=True option that can avoid unnecessary retracing. For (3), please refer to https://www.tensorflow.org/guide/function#controlling_retracing and https://www.tensorflow.org/api_docs/python/tf/function for  more details.\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/home/runner/work/scikeras/scikeras/.venv/lib/python3.8/site-packages/keras/optimizers/optimizer_v2/adam.py:110: UserWarning: The `lr` argument is deprecated, use `learning_rate` instead.\n",
      "  super(Adam, self).__init__(name, **kwargs)\n",
      "WARNING:tensorflow:5 out of the last 13 calls to <function Model.make_train_function.<locals>.train_function at 0x7f0250256310> triggered tf.function retracing. Tracing is expensive and the excessive number of tracings could be due to (1) creating @tf.function repeatedly in a loop, (2) passing tensors with different shapes, (3) passing Python objects instead of tensors. For (1), please define your @tf.function outside of the loop. For (2), @tf.function has reduce_retracing=True option that can avoid unnecessary retracing. For (3), please refer to https://www.tensorflow.org/guide/function#controlling_retracing and https://www.tensorflow.org/api_docs/python/tf/function for  more details.\n",
      "WARNING:tensorflow:6 out of the last 6 calls to <function Model.make_predict_function.<locals>.predict_function at 0x7f02502561f0> triggered tf.function retracing. Tracing is expensive and the excessive number of tracings could be due to (1) creating @tf.function repeatedly in a loop, (2) passing tensors with different shapes, (3) passing Python objects instead of tensors. For (1), please define your @tf.function outside of the loop. For (2), @tf.function has reduce_retracing=True option that can avoid unnecessary retracing. For (3), please refer to https://www.tensorflow.org/guide/function#controlling_retracing and https://www.tensorflow.org/api_docs/python/tf/function for  more details.\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/home/runner/work/scikeras/scikeras/.venv/lib/python3.8/site-packages/keras/optimizers/optimizer_v2/adam.py:110: UserWarning: The `lr` argument is deprecated, use `learning_rate` instead.\n",
      "  super(Adam, self).__init__(name, **kwargs)\n",
      "WARNING:tensorflow:5 out of the last 13 calls to <function Model.make_train_function.<locals>.train_function at 0x7faf30fa33a0> triggered tf.function retracing. Tracing is expensive and the excessive number of tracings could be due to (1) creating @tf.function repeatedly in a loop, (2) passing tensors with different shapes, (3) passing Python objects instead of tensors. For (1), please define your @tf.function outside of the loop. For (2), @tf.function has reduce_retracing=True option that can avoid unnecessary retracing. For (3), please refer to https://www.tensorflow.org/guide/function#controlling_retracing and https://www.tensorflow.org/api_docs/python/tf/function for  more details.\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "WARNING:tensorflow:6 out of the last 6 calls to <function Model.make_predict_function.<locals>.predict_function at 0x7faf30fa3430> triggered tf.function retracing. Tracing is expensive and the excessive number of tracings could be due to (1) creating @tf.function repeatedly in a loop, (2) passing tensors with different shapes, (3) passing Python objects instead of tensors. For (1), please define your @tf.function outside of the loop. For (2), @tf.function has reduce_retracing=True option that can avoid unnecessary retracing. For (3), please refer to https://www.tensorflow.org/guide/function#controlling_retracing and https://www.tensorflow.org/api_docs/python/tf/function for  more details.\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/home/runner/work/scikeras/scikeras/.venv/lib/python3.8/site-packages/keras/optimizers/optimizer_v2/adam.py:110: UserWarning: The `lr` argument is deprecated, use `learning_rate` instead.\n",
      "  super(Adam, self).__init__(name, **kwargs)\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0.8600000000000001 {'model__dropout': 0.5, 'model__hidden_layer_sizes': (100,), 'optimizer__lr': 0.1}\n"
     ]
    }
   ],
   "source": [
    "params = {\n",
    "    'optimizer__lr': [0.05, 0.1],\n",
    "    'model__hidden_layer_sizes': [(100, ), (50, 50, )],\n",
    "    'model__dropout': [0, 0.5],\n",
    "}\n",
    "\n",
    "gs = GridSearchCV(clf, params, scoring='accuracy', n_jobs=-1, verbose=True)\n",
    "\n",
    "gs.fit(X, y)\n",
    "\n",
    "print(gs.best_score_, gs.best_params_)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f2438d0d",
   "metadata": {},
   "source": [
    "Of course, we could further nest the `KerasClassifier` within an `sklearn.pipeline.Pipeline`,\n",
    "in which case we just prefix the parameter by the name of the net (e.g. `clf__model__hidden_layer_sizes`)."
   ]
  }
 ],
 "metadata": {
  "jupytext": {
   "formats": "ipynb,md"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.13"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
