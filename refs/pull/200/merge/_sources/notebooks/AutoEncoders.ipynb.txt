{
 "cells": [
  {
   "cell_type": "raw",
   "id": "tired-accessory",
   "metadata": {},
   "source": [
    "<a href=\"https://colab.research.google.com/github/adriangb/scikeras/blob/docs-deploy/refs/heads/master/notebooks/AutoEncoders.ipynb\"><img src=\"https://www.tensorflow.org/images/colab_logo_32px.png\">Run in Google Colab</a>"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "overall-device",
   "metadata": {},
   "source": [
    "# Autoencoders in SciKeras\n",
    "\n",
    "Autencoders are an approach to use nearual networks to distill data into it's most important features, thereby compressing the data.\n",
    "We will be following the [Keras tutorial](https://blog.keras.io/building-autoencoders-in-keras.html) on the topic, which goes much more in depth and breadth than we will here.\n",
    "You are highly encouraged to check out that tutorial if you want to learn about autoencoders in the general sense.\n",
    "\n",
    "## Table of contents\n",
    "\n",
    "* [1. Setup](#1.-Setup)\n",
    "* [2. Data](#2.-Data)\n",
    "* [3. Define Keras Model](#3.-Define-Keras-Model)\n",
    "* [4. Training](#4.-Training)\n",
    "* [5. Explore Results](#5.-Explore-Results)\n",
    "* [6. Deep AutoEncoder](#6.-Deep-AutoEncoder)\n",
    "\n",
    "## 1. Setup"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "cardiac-fraud",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-02-20T07:55:20.986551Z",
     "iopub.status.busy": "2021-02-20T07:55:20.983157Z",
     "iopub.status.idle": "2021-02-20T07:55:24.070361Z",
     "shell.execute_reply": "2021-02-20T07:55:24.069404Z"
    }
   },
   "outputs": [],
   "source": [
    "try:\n",
    "    import scikeras\n",
    "except ImportError:\n",
    "    !python -m pip install scikeras"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "interim-buffer",
   "metadata": {},
   "source": [
    "Silence TensorFlow logging to keep output succinct."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "interstate-digest",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-02-20T07:55:24.075706Z",
     "iopub.status.busy": "2021-02-20T07:55:24.075126Z",
     "iopub.status.idle": "2021-02-20T07:55:24.083040Z",
     "shell.execute_reply": "2021-02-20T07:55:24.083585Z"
    }
   },
   "outputs": [],
   "source": [
    "import warnings\n",
    "from tensorflow import get_logger\n",
    "get_logger().setLevel('ERROR')\n",
    "warnings.filterwarnings(\"ignore\", message=\"Setting the random state for TF\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "arabic-secret",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-02-20T07:55:24.086451Z",
     "iopub.status.busy": "2021-02-20T07:55:24.085613Z",
     "iopub.status.idle": "2021-02-20T07:55:24.413418Z",
     "shell.execute_reply": "2021-02-20T07:55:24.412763Z"
    }
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "from scikeras.wrappers import KerasClassifier, KerasRegressor\n",
    "from tensorflow import keras"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "desirable-creek",
   "metadata": {},
   "source": [
    "## 2. Data\n",
    "\n",
    "We load the dataset from the Keras tutorial. The dataset consists of images of cats and dogs."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "utility-blame",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-02-20T07:55:24.425224Z",
     "iopub.status.busy": "2021-02-20T07:55:24.424575Z",
     "iopub.status.idle": "2021-02-20T07:55:25.043401Z",
     "shell.execute_reply": "2021-02-20T07:55:25.044273Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Downloading data from https://storage.googleapis.com/tensorflow/tf-keras-datasets/mnist.npz\n",
      "\r",
      "    8192/11490434 [..............................] - ETA: 0s"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\r",
      " 3801088/11490434 [========>.....................] - ETA: 0s"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\r",
      " 9519104/11490434 [=======================>......] - ETA: 0s"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\r",
      "11493376/11490434 [==============================] - 0s 0us/step\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(60000, 784)\n",
      "(10000, 784)\n"
     ]
    }
   ],
   "source": [
    "from tensorflow.keras.datasets import mnist\n",
    "import numpy as np\n",
    "\n",
    "\n",
    "(x_train, _), (x_test, _) = mnist.load_data()\n",
    "x_train = x_train.astype('float32') / 255.\n",
    "x_test = x_test.astype('float32') / 255.\n",
    "x_train = x_train.reshape((len(x_train), np.prod(x_train.shape[1:])))\n",
    "x_test = x_test.reshape((len(x_test), np.prod(x_test.shape[1:])))\n",
    "print(x_train.shape)\n",
    "print(x_test.shape)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "dietary-personal",
   "metadata": {},
   "source": [
    "## 3. Define Keras Model\n",
    "\n",
    "We will be defining a very simple autencoder. We define _three_ models:\n",
    "\n",
    "1. An encoder\n",
    "2. A decoder\n",
    "3. An autoencoder (which is just a chain of the encoder and decoder)\n",
    "\n",
    "The only variable we give our model is the encoding dimensions, which will be a hyperparemter of our final transformer.\n",
    "\n",
    "We will build these models within `_keras-build_fn` so that we can store our encoders and decoders as seperate models and call them from `transform` and `inverse_transform` respectively.\n",
    "\n",
    "For a background on chaining Functional Models like this, see [All models are callable](https://keras.io/guides/functional_api/#all-models-are-callable-just-like-layers) in the Keras docs."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "starting-brooks",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-02-20T07:55:25.048214Z",
     "iopub.status.busy": "2021-02-20T07:55:25.047054Z",
     "iopub.status.idle": "2021-02-20T07:55:25.061013Z",
     "shell.execute_reply": "2021-02-20T07:55:25.061831Z"
    }
   },
   "outputs": [],
   "source": [
    "from typing import Dict, Any\n",
    "\n",
    "from sklearn.base import TransformerMixin\n",
    "from sklearn.metrics import mean_squared_error\n",
    "from scikeras.wrappers import BaseWrapper\n",
    "\n",
    "\n",
    "class AutoEncoder(BaseWrapper, TransformerMixin):\n",
    "    \"\"\"A class that enables transform and fit_transform.\n",
    "    \"\"\"\n",
    "    \n",
    "    def _keras_build_fn(self, encoding_dim: int, meta: Dict[str, Any]):\n",
    "        n_features_in = meta[\"n_features_in_\"]\n",
    "\n",
    "        encoder_input = keras.Input(shape=(n_features_in,))\n",
    "        encoder_output = keras.layers.Dense(encoding_dim, activation='relu')(encoder_input)\n",
    "        encoder_model = keras.Model(encoder_input, encoder_output)\n",
    "\n",
    "        decoder_input = keras.Input(shape=(encoding_dim,))\n",
    "        decoder_output = keras.layers.Dense(n_features_in, activation='sigmoid', name=\"decoder\")(decoder_input)\n",
    "        decoder_model = keras.Model(decoder_input, decoder_output)\n",
    "        \n",
    "        autoencoder_input = keras.Input(shape=(n_features_in,))\n",
    "        encoded_img = encoder_model(autoencoder_input)\n",
    "        reconstructed_img = decoder_model(encoded_img)\n",
    "\n",
    "        autoencoder_model = keras.Model(autoencoder_input, reconstructed_img)\n",
    "\n",
    "        self.encoder_model_ = BaseWrapper(encoder_model, verbose=self.verbose)\n",
    "        self.decoder_model_ = BaseWrapper(decoder_model, verbose=self.verbose)\n",
    "\n",
    "        return autoencoder_model\n",
    "    \n",
    "    def _initialize(self, X, y=None):\n",
    "        X, _ = super()._initialize(X=X, y=y)\n",
    "        # since encoder_model_ and decoder_model_ share layers (and their weights)\n",
    "        # X_tf here come from random weights, but we only use it to initialize our models\n",
    "        X_tf = self.encoder_model_.initialize(X).predict(X)\n",
    "        self.decoder_model_.initialize(X_tf)\n",
    "        return X, X\n",
    "\n",
    "    def initialize(self, X):\n",
    "        self._initialize(X=X, y=X)\n",
    "        return self\n",
    "\n",
    "    def fit(self, X, *, sample_weight=None):\n",
    "        super().fit(X=X, y=X, sample_weight=sample_weight)\n",
    "        # at this point, encoder_model_ and decoder_model_\n",
    "        # are both \"fitted\" because they share layers w/ model_\n",
    "        # which is fit in the above call\n",
    "        return self\n",
    "\n",
    "    def score(self, X) -> float:\n",
    "        # Note: we use 1-MSE as the score\n",
    "        # With MSE, \"larger is better\", but Scikit-Learn\n",
    "        # always maximizes the score (e.g. in GridSearch)\n",
    "        return 1 - mean_squared_error(self.predict(X), X)\n",
    "\n",
    "    def transform(self, X):\n",
    "        X = self.feature_encoder_.transform(X)\n",
    "        return self.encoder_model_.predict(X)\n",
    "\n",
    "    def inverse_transform(self, X_tf):\n",
    "        X = self.decoder_model_.predict(X_tf)\n",
    "        return self.feature_encoder_.inverse_transform(X)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "metric-library",
   "metadata": {},
   "source": [
    "Next, we wrap the Keras Model with Scikeras. Note that for our encoder/decoder estimators, we do not need to provide a loss function since no training will be done.\n",
    "We do however need to have the `fit_model` and `encoding_dim` so that these will be settable by `BaseWrapper.set_params`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "dependent-seller",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-02-20T07:55:25.066420Z",
     "iopub.status.busy": "2021-02-20T07:55:25.065308Z",
     "iopub.status.idle": "2021-02-20T07:55:25.070152Z",
     "shell.execute_reply": "2021-02-20T07:55:25.070859Z"
    }
   },
   "outputs": [],
   "source": [
    "autoencoder = AutoEncoder(\n",
    "    loss=\"binary_crossentropy\",\n",
    "    encoding_dim=32,\n",
    "    random_state=0,\n",
    "    epochs=15,\n",
    "    verbose=False,\n",
    "    optimizer=\"adam\",\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "illegal-activity",
   "metadata": {},
   "source": [
    "## 4. Training\n",
    "\n",
    "To train the model, we pass the input images as both the features and the target.\n",
    "This will train the layers to compress the data as accurately as possible between the encoder and decoder.\n",
    "Note that we only pass the `X` parameter, since we defined the mapping `y=X` in `KerasTransformer.fit` above."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "nutritional-fusion",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-02-20T07:55:25.074676Z",
     "iopub.status.busy": "2021-02-20T07:55:25.073148Z",
     "iopub.status.idle": "2021-02-20T07:56:27.201269Z",
     "shell.execute_reply": "2021-02-20T07:56:27.201929Z"
    }
   },
   "outputs": [],
   "source": [
    "_ = autoencoder.fit(X=x_train)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "extra-metropolitan",
   "metadata": {},
   "source": [
    "Next, we round trip the test dataset and explore the performance of the autoencoder."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "scenic-coordination",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-02-20T07:56:27.206725Z",
     "iopub.status.busy": "2021-02-20T07:56:27.206138Z",
     "iopub.status.idle": "2021-02-20T07:56:28.026610Z",
     "shell.execute_reply": "2021-02-20T07:56:28.027449Z"
    }
   },
   "outputs": [],
   "source": [
    "roundtrip_imgs = autoencoder.inverse_transform(autoencoder.transform(x_test))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "phantom-suffering",
   "metadata": {},
   "source": [
    "## 5. Explore Results\n",
    "\n",
    "Let's compare our inputs to lossy decoded outputs:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "adequate-arlington",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-02-20T07:56:28.031452Z",
     "iopub.status.busy": "2021-02-20T07:56:28.030218Z",
     "iopub.status.idle": "2021-02-20T07:56:31.048958Z",
     "shell.execute_reply": "2021-02-20T07:56:31.049890Z"
    }
   },
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAABG0AAADnCAYAAACkCqtqAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjMuNCwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy8QVMy6AAAACXBIWXMAAAsTAAALEwEAmpwYAABB/UlEQVR4nO3dd7wU1fnH8YOKChYQpClVsCugIDYwqFiiqJhoLERN7DXG2MtPjZr4+2GPHbugxihGxYIFRSWKBRUVAYNKL4IUFcF6f3/k5ZPvedgd9y67e+fOft5/PeM5d3fY2TMzO57nPA1qamoCAAAAAAAA0mWlut4BAAAAAAAALI+HNgAAAAAAACnEQxsAAAAAAIAU4qENAAAAAABACvHQBgAAAAAAIIV4aAMAAAAAAJBCq9Smc4MGDagPXkdqamoalOJ1OIZ1an5NTU2LUrwQx7HuMBYzgbGYAYzFTGAsZgBjMRMYixnAWMyEnGORmTZA5Uyt6x0AEEJgLAJpwVgE0oGxCKRDzrHIQxsAAAAAAIAU4qENAAAAAABACvHQBgAAAAAAIIV4aAMAAAAAAJBCPLQBAAAAAABIIR7aAAAAAAAApBAPbQAAAAAAAFKIhzYAAAAAAAAptEpd7wCq0xlnnGFxo0aNorauXbtafMABB+R9jZtvvtni1157LWobMmTIiu4iAAAAAAB1ipk2AAAAAAAAKcRDGwAAAAAAgBTioQ0AAAAAAEAKsaYNKubBBx+0OGmtGvXjjz/mbTvuuOMs7tevX9T20ksvWTxt2rRCdxF1bKONNoq2J06caPGpp55q8fXXX1+xfapma6yxhsVXXHGFxTr2Qghh7NixFh944IFR29SpU8u0dwAAAHVjnXXWsbh9+/YF/Y2/JzrttNMs/uCDDyz+6KOPon7jxo0rZheRIcy0AQAAAAAASCEe2gAAAAAAAKQQ6VEoG02HCqHwlChNiXnmmWcs3mCDDaJ+++yzj8WdO3eO2gYOHGjx5ZdfXtD7ou5ttdVW0bamx82YMaPSu1P12rRpY/ExxxxjsU9b7NGjh8X9+/eP2m688cYy7R3U1ltvbfEjjzwStXXs2LFs77v77rtH2xMmTLB4+vTpZXtf/Dy9RoYQwuOPP27xySefbPEtt9wS9fvhhx/Ku2MZ1LJlS4v/8Y9/WPzqq69G/QYPHmzxlClTyr5fP2nSpEm0vdNOO1k8YsQIi7/77ruK7RNQH+y9994W77vvvlFb3759Le7SpUtBr+fTnjp06GDxaqutlvfvVl555YJeH9nFTBsAAAAAAIAU4qENAAAAAABACpEehZLq2bOnxfvvv3/efuPHj7fYTzecP3++xV999ZXFq666atRvzJgxFnfr1i1qa968eYF7jDTp3r17tL1kyRKL//nPf1Z4b6pPixYtou177rmnjvYEtbXHHntYnDTFutR8Cs6RRx5p8cEHH1yx/cB/6LXvpptuytvvhhtusPjOO++M2pYuXVr6HcsYrRoTQnxPo6lIc+fOjfrVVUqUVvgLIT7Xa3rr5MmTy79j9czaa68dbWvK/RZbbGGxr2JKqlm66bIKJ510ksWaCh5CCI0aNbK4QYMGK/y+vkoqUChm2gAAAAAAAKQQD20AAAAAAABSiIc2AAAAAAAAKVSna9r4EtCaRzhr1qyobdmyZRbfd999Fs+ZMyfqRz5u3dISwT73U3O+df2F2bNnF/Tap59+erS92Wab5e375JNPFvSaqHuaE65laEMIYciQIZXenarzhz/8weIBAwZEbb169ar162kp2RBCWGml//6/gXHjxln88ssv1/q1EVtllf9ewvfaa6862Qe/Vsaf/vQni9dYY42oTdeoQnno+Gvbtm3efg888IDFen+F/NZdd12LH3zwwaitWbNmFutaQqecckr5dyyPCy64wOJOnTpFbccdd5zF3Dcvb+DAgRb/5S9/idratWuX82/82jeff/556XcMJaPnx1NPPbWs7zVx4kSL9bcQSkdLruu5OoR4jVUt0x5CCD/++KPFt9xyi8X/+te/on5pOE8y0wYAAAAAACCFeGgDAAAAAACQQnWaHjVo0KBou2PHjgX9nU7r/PLLL6O2Sk47mzFjhsX+3/LWW29VbD/SZPjw4RbrVLUQ4mO1YMGCWr+2Lx/bsGHDWr8G0meTTTax2KdT+CnoKL1rrrnGYp0mWqxf/epXebenTp1q8UEHHRT182k2+Hk777yzxdtvv73F/npUTr70saatNm7cOGojPar0fHn3888/v6C/09TTmpqaku5TVm299dYW+yn26pJLLqnA3ixv8803j7Y1pfyf//xn1Ma1dXmaLnPttdda3Lx586hfvvFy/fXXR9ua7l3MPS8K41NhNNVJU1xGjBgR9fvmm28sXrx4scX+OqX3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75cuXRptb7rppjnjEOL73FatWuXdJzV37txou1Jp4cy0AQAAAAAASCEe2gAAAAAAAKQQ6VEhhB133DHa9quU/0RXMg8hhA8++KBcu5R5w4YNs7h58+Z5+w0dOtTiaqsakyX9+vWzuFmzZlHbiBEjLNaqDCgdX/lO6dTTctMp/36fkvbx4osvtviwww4r+X6lia9osv7661v8wAMPVHp3TOfOnXP+d66DlZeUhlGKykX4j7Fjx0bbXbt2tbh79+5R25577mmxVkWZN29e1O+ee+4p6L21Gsm4cePy9nv11Vct5h6pdvz5VFPZNAXRp2BoBcz999/fYl9tRseibzvmmGMs1mP94YcfFrLrVcGnwigdbxdddFHU9thjj1lMxbz0eOGFF6JtTaXW3wghhNC+fXuL//a3v1mclCqq6VY+FStJvpSoH3/8Mdr+5z//afEf/vCHqG327NkFv9+KYKYNAAAAAABACvHQBgAAAAAAIIV4aAMAAAAAAJBCrGkTQthrr72i7YYNG1o8cuRIi1977bWK7VMWab7w1ltvnbffqFGjLPa5qqifunXrZrHPSX344YcrvTtV4fjjj7fY5+bWlX322cfirbbaKmrTffT7q2vaZN2XX34ZbWtOvq6pEUK8PtSCBQtKuh8tW7aMtvOtLzB69OiSvi9y6927t8WHHnpo3n6LFy+2mFK4pbVw4UKLfWl73T777LNX+L022GADi3UtsBDic8IZZ5yxwu9VrZ5//vloW8eOrlvj15nJt66Gf72TTjrJ4ieeeCJq23DDDS3W9TH0ul3tWrRoYbG/J9C13y688MKo7YILLrD4lltusVjLrIcQr5syefJki8ePH593nzbffPNoW38Xcr5N5stw63pQTZs2jdp0bVldd/bzzz+P+k2bNs1i/U7ob44QQujVq1et93fw4MHR9nnnnWexrldVScy0AQAAAAAASCEe2gAAAAAAAKRQ1aZHNWrUyGItHRdCCN9++63Fmp7z3XfflX/HMsSX8tapZZqC5unU36+++qrk+4XKaN26tcV9+vSxeNKkSVE/LaOH0tFUpErSKc0hhLDZZptZrOeAJL5MbjWde/0UYi3j++tf/zpqe/LJJy2++uqra/1eW2yxRbStKRkdO3aM2vKlBKQl9S7r9Hq60kr5/3/bc889V4ndQZlpyocfe5p+5c+VKJxPKf3Nb35j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\n",
      "text/plain": [
       "<Figure size 1440x288 with 20 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "\n",
    "\n",
    "n = 10  # How many digits we will display\n",
    "plt.figure(figsize=(20, 4))\n",
    "for i in range(n):\n",
    "    # Display original\n",
    "    ax = plt.subplot(2, n, i + 1)\n",
    "    plt.imshow(x_test[i].reshape(28, 28))\n",
    "    plt.gray()\n",
    "    ax.get_xaxis().set_visible(False)\n",
    "    ax.get_yaxis().set_visible(False)\n",
    "\n",
    "    # Display reconstruction\n",
    "    ax = plt.subplot(2, n, i + 1 + n)\n",
    "    plt.imshow(roundtrip_imgs[i].reshape(28, 28))\n",
    "    plt.gray()\n",
    "    ax.get_xaxis().set_visible(False)\n",
    "    ax.get_yaxis().set_visible(False)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "surgical-siemens",
   "metadata": {},
   "source": [
    "What about the compression? Let's check the sizes of the arrays."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "charming-section",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-02-20T07:56:31.054135Z",
     "iopub.status.busy": "2021-02-20T07:56:31.052892Z",
     "iopub.status.idle": "2021-02-20T07:56:31.514342Z",
     "shell.execute_reply": "2021-02-20T07:56:31.513894Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "x_test size (in MB): 29.91\n",
      "encoded_imgs size (in MB): 1.22\n",
      "Compression ratio: 1/25\n"
     ]
    }
   ],
   "source": [
    "encoded_imgs = autoencoder.transform(x_test)\n",
    "print(f\"x_test size (in MB): {x_test.nbytes/1024**2:.2f}\")\n",
    "print(f\"encoded_imgs size (in MB): {encoded_imgs.nbytes/1024**2:.2f}\")\n",
    "cr = round((encoded_imgs.nbytes/x_test.nbytes), 2)\n",
    "print(f\"Compression ratio: 1/{1/cr:.0f}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "moved-silicon",
   "metadata": {},
   "source": [
    "## 6. Deep AutoEncoder"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "flexible-knock",
   "metadata": {},
   "source": [
    "We can easily expand our model to be a deep autoencoder by adding some hidden layers. All we have to do is add a parameter `hidden_layer_sizes` and use it in `_keras_build_fn` to build hidden layers.\n",
    "For simplicity, we use a single `hidden_layer_sizes` parameter and mirror it across the encoding layers and decoding layers, but there is nothing forcing us to build symetrical models."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "front-central",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-02-20T07:56:31.522723Z",
     "iopub.status.busy": "2021-02-20T07:56:31.522226Z",
     "iopub.status.idle": "2021-02-20T07:56:31.535616Z",
     "shell.execute_reply": "2021-02-20T07:56:31.536100Z"
    }
   },
   "outputs": [],
   "source": [
    "from typing import List\n",
    "\n",
    "\n",
    "class DeepAutoEncoder(AutoEncoder):\n",
    "    \"\"\"A class that enables transform and fit_transform.\n",
    "    \"\"\"\n",
    "    \n",
    "    def _keras_build_fn(self, encoding_dim: int, hidden_layer_sizes: List[str], meta: Dict[str, Any]):\n",
    "        n_features_in = meta[\"n_features_in_\"]\n",
    "\n",
    "        encoder_input = keras.Input(shape=(n_features_in,))\n",
    "        x = encoder_input\n",
    "        for layer_size in hidden_layer_sizes:\n",
    "            x = keras.layers.Dense(layer_size, activation='relu')(x)\n",
    "        encoder_output = keras.layers.Dense(encoding_dim, activation='relu')(x)\n",
    "        encoder_model = keras.Model(encoder_input, encoder_output)\n",
    "\n",
    "        decoder_input = keras.Input(shape=(encoding_dim,))\n",
    "        x = decoder_input\n",
    "        for layer_size in reversed(hidden_layer_sizes):\n",
    "            x = keras.layers.Dense(layer_size, activation='relu')(x)\n",
    "        decoder_output = keras.layers.Dense(n_features_in, activation='sigmoid', name=\"decoder\")(x)\n",
    "        decoder_model = keras.Model(decoder_input, decoder_output)\n",
    "\n",
    "        autoencoder_input = keras.Input(shape=(n_features_in,))\n",
    "        encoded_img = encoder_model(autoencoder_input)\n",
    "        reconstructed_img = decoder_model(encoded_img)\n",
    "\n",
    "        autoencoder_model = keras.Model(autoencoder_input, reconstructed_img)\n",
    "\n",
    "        self.encoder_model_ = BaseWrapper(encoder_model, verbose=self.verbose)\n",
    "        self.decoder_model_ = BaseWrapper(decoder_model, verbose=self.verbose)\n",
    "\n",
    "        return autoencoder_model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "future-solid",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-02-20T07:56:31.541767Z",
     "iopub.status.busy": "2021-02-20T07:56:31.541143Z",
     "iopub.status.idle": "2021-02-20T07:58:25.027822Z",
     "shell.execute_reply": "2021-02-20T07:58:25.028419Z"
    }
   },
   "outputs": [],
   "source": [
    "deep = DeepAutoEncoder(\n",
    "    loss=\"binary_crossentropy\",\n",
    "    encoding_dim=32,\n",
    "    hidden_layer_sizes=[128],\n",
    "    random_state=0,\n",
    "    epochs=15,\n",
    "    verbose=False,\n",
    "    optimizer=\"adam\",\n",
    ")\n",
    "_ = deep.fit(X=x_train)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "square-sapphire",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-02-20T07:58:25.034481Z",
     "iopub.status.busy": "2021-02-20T07:58:25.033798Z",
     "iopub.status.idle": "2021-02-20T07:58:26.316745Z",
     "shell.execute_reply": "2021-02-20T07:58:26.317600Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1-MSE for training set (higher is better)\n",
      "\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "AutoEncoder: 0.9901\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Deep AutoEncoder: 0.9921\n"
     ]
    }
   ],
   "source": [
    "print(\"1-MSE for training set (higher is better)\\n\")\n",
    "score = autoencoder.score(X=x_test)\n",
    "print(f\"AutoEncoder: {score:.4f}\")\n",
    "\n",
    "score = deep.score(X=x_test)\n",
    "print(f\"Deep AutoEncoder: {score:.4f}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "legislative-operator",
   "metadata": {},
   "source": [
    "Suprisingly, our score got worse. It's possible that that because of the extra trainable variables, our deep model trains slower than our simple model.\n",
    "\n",
    "Check out the [Keras tutorial](https://blog.keras.io/building-autoencoders-in-keras.html) to see the difference after 100 epochs of training, as well as more architectures and applications for AutoEncoders!"
   ]
  }
 ],
 "metadata": {
  "jupytext": {
   "formats": "ipynb,md"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
